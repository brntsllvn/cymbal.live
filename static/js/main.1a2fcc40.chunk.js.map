{"version":3,"sources":["components/NowPlaying.js","components/ComingUp.js","components/ShowAPI.js","components/ShowContainer.js","App.js","serviceWorker.js","index.js"],"names":["NowPlaying","show","this","props","artist","React","Component","ComingUp","shows","map","key","hashCode","time","toString","href","link","target","ShowAPI","fetch","fileContents","parse","response","text","txt","showRaw","split","raw","showData","length","datetimeParseable","momentize","hash","push","strDate","moment","isValid","error","console","str","i","charCodeAt","ShowContainer","state","nowPlaying","api","getShows","_getUpcomingShows","Array","isArray","setState","App","ReactGA","initialize","pageview","window","location","pathname","search","Boolean","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","message"],"mappings":"mTAoBeA,E,uKAfP,IAAMC,EAAOC,KAAKC,MAAMF,KACxB,OACI,4CACiBA,EAAKG,a,GALTC,IAAMC,WC2BhBC,E,uKAzBP,IAAMC,EAAQN,KAAKC,MAAMK,MACzB,OACI,6BACI,4CAEIA,EAAMC,KAAI,SAAAR,GACN,OACI,uBAAGS,IAAKT,EAAKU,UACRV,EAAKW,KAAKC,WACVZ,EAAKG,OACN,uBAAGU,KAAMb,EAAKc,KAAMC,OAAO,UAA3B,iB,GAZTX,IAAMC,W,gBC2DdW,E,qOA1DoBf,KAAKgB,Q,cAA1BC,E,OACAX,EAAQN,KAAKkB,MAAMD,G,kBAClBX,G,kWAIgBU,MAAM,kB,cAAvBG,E,gBACYA,EAASC,O,cAArBC,E,yBACCA,G,yEAGLJ,GAAe,IAAD,OACVK,EAAUL,EAAaM,MAAM,MAC/BjB,EAAQ,GAkBZ,OAjBAgB,EAAQf,KAAI,SAAAiB,GACR,IAAMC,EAAWD,EAAID,MAAM,MAC3B,GACKE,KACDA,EAASC,OAAS,IACjB,EAAKC,kBAAkBF,EAAS,IAHrC,CAOA,IAAI1B,EAAO,CACP,OAAU0B,EAAS,GACnB,KAAQ,EAAKG,UAAUH,EAAS,IAChC,KAAQA,EAAS,GACjB,SAAY,EAAKI,KAAKL,IAE1BlB,EAAMwB,KAAK/B,OAERO,I,wCAGOyB,GACd,IACI,OAAOC,IAAOD,GAASE,UACzB,MAAOC,GACLC,QAAQD,MAAR,0CAAiDH,O,gCAI/CA,GACN,OAAOC,IAAOD,K,2BAGbK,GAED,IAAcC,EAAVR,EAAO,EACP,IAAKQ,EAAI,EAAGA,EAAIrC,KAAK0B,OAAQW,IAEzBR,GAAUA,GAAQ,GAAKA,EADf7B,KAAKsC,WAAWD,GAExBR,GAAQ,EAEhB,OAAOA,M,KChBAU,E,kDApCX,WAAYtC,GAAQ,IAAD,8BACf,cAAMA,IACDuC,MAAQ,CACTC,WAAY,mBACZnC,MAAO,IAJI,E,yLASToC,EAAM,IAAI3B,E,SACI2B,EAAIC,W,cAAlBrC,E,yBACCA,G,2QAIaN,KAAK4C,oB,WAAnBtC,E,SACSuC,MAAMC,QAAQxC,MAAUA,EAAMoB,OAAS,G,iDAGtD1B,KAAK+C,SAAS,CACVN,WAAYnC,EAAM,GAClBA,MAAOA,I,qIAKX,OACI,6BACI,kBAAC,EAAD,CAAYP,KAAMC,KAAKwC,MAAMC,aAC7B,kBAAC,EAAD,CAAUnC,MAAON,KAAKwC,MAAMlC,a,GA9BhBH,IAAMC,WC0BnB4C,MA1Bf,WAKE,OAHAC,IAAQC,WADW,kBAEnBD,IAAQE,SAASC,OAAOC,SAASC,SAAWF,OAAOC,SAASE,QAG1D,6BACE,6BACE,4CAEF,0CAGA,gDAGA,wCAGA,6BACE,kBAAC,EAAD,SCbYC,QACW,cAA7BJ,OAAOC,SAASI,UAEe,UAA7BL,OAAOC,SAASI,UAEhBL,OAAOC,SAASI,SAASC,MACvB,2DCZNC,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,EAAD,OAEFC,SAASC,eAAe,SDyHpB,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAApC,GACLC,QAAQD,MAAMA,EAAMqC,c","file":"static/js/main.1a2fcc40.chunk.js","sourcesContent":["import React from 'react';\nimport PropTypes from 'prop-types';\n\nclass NowPlaying extends React.Component {    \n    render () {\n        const show = this.props.show\n        return (\n            <h1>{\n                    `LIVE: ${show.artist}`\n                }\n            </h1>\n        ); \n    }\n    \n}\n\nNowPlaying.propTypes = {\n    show: PropTypes.any.isRequired\n}\n\nexport default NowPlaying;","import React from 'react';\nimport PropTypes from 'prop-types';\n\nclass ComingUp extends React.Component {\n    render() {\n        const shows = this.props.shows\n        return (\n            <div>\n                <h1>Coming up...</h1>\n                {\n                    shows.map(show => {\n                        return (\n                            <p key={show.hashCode}>\n                                {show.time.toString()} \n                                {show.artist}\n                                <a href={show.link} target='_blank'>link</a>\n                            </p>\n                        )\n                    })\n                }\n            </div>\n        );\n    }\n\n}\n\nComingUp.propTypes = {\n    shows: PropTypes.any.isRequired\n}\n\nexport default ComingUp;","import moment from 'moment'\n\nclass ShowAPI {\n    async getShows() {\n        const fileContents = await this.fetch();\n        const shows = this.parse(fileContents);\n        return shows;\n    }\n\n    async fetch() {\n        const response = await fetch('2020-03-22.txt');\n        const txt = await response.text();\n        return txt;\n    }\n\n    parse(fileContents) {\n        const showRaw = fileContents.split('\\n');\n        let shows = [];\n        showRaw.map(raw => {\n            const showData = raw.split('||');\n            if (\n                !showData ||\n                showData.length < 3 ||\n                !this.datetimeParseable(showData[1])\n            ) {\n                return;\n            }\n            let show = {\n                'artist': showData[0],\n                'time': this.momentize(showData[1]),\n                'link': showData[2],\n                'hashCode': this.hash(raw)\n            }\n            shows.push(show)\n        })\n        return shows;\n    }\n\n    datetimeParseable(strDate) {\n        try {\n            return moment(strDate).isValid();\n        } catch (error) {\n            console.error(`Cannot parse this weird date => ${strDate}`)\n        }\n    }\n\n    momentize(strDate) {\n        return moment(strDate);\n    }\n\n    hash(str) {\n        // from the wild interwebs...\n        var hash = 0, i, chr;\n            for (i = 0; i < this.length; i++) {\n                chr   = this.charCodeAt(i);\n                hash  = ((hash << 5) - hash) + chr;\n                hash |= 0;\n            }\n        return hash;\n    }\n}\n\nexport default ShowAPI","import React from 'react';\nimport NowPlaying from './NowPlaying';\nimport ComingUp from './ComingUp';\nimport ShowAPI from './ShowAPI';\n\nclass ShowContainer extends React.Component {    \n    constructor(props) {\n        super(props);\n        this.state = {\n            nowPlaying: 'Check back soon!',\n            shows: []\n        }\n    }\n\n    async _getUpcomingShows() {\n        const api = new ShowAPI();\n        const shows = await api.getShows();\n        return shows;\n    }\n\n    async componentDidMount() {\n        const shows = await this._getUpcomingShows(); \n        if (!shows || !Array.isArray(shows) || shows.length < 1) {\n            return;\n        }\n        this.setState({ \n            nowPlaying: shows[0],\n            shows: shows,\n        })\n    }\n\n    render () {\n        return (\n            <div>\n                <NowPlaying show={this.state.nowPlaying}/>\n                <ComingUp shows={this.state.shows} />\n            </div>\n        ); \n    }\n    \n}\n\nexport default ShowContainer;","import React from 'react';\nimport './App.css';\nimport ReactGA from 'react-ga';\nimport ShowContainer from './components/ShowContainer'\n\nfunction App() {\n  const trackingId = \"UA-161532154-1\";\n  ReactGA.initialize(trackingId);\n  ReactGA.pageview(window.location.pathname + window.location.search);\n\n  return (\n    <div>\n      <div>\n        <h1>cymbal.live</h1>\n      </div>\n      <div>\n        say hello\n      </div>\n      <div>\n        request feature\n      </div>\n      <div>\n        support\n      </div>\n      <div>\n        <ShowContainer />\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}